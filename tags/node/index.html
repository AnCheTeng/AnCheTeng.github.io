<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="I will record my learning process with MEAN-MongoDB, Express.js, Angular.js and Node.js here!"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Be a MEAN-Stack." type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>node - Be a MEAN-Stack.</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">Be a MEAN-Stack.</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2016-03-26T11:27:13.000Z" class="post__time">March 26, 2016</time><h1 class="post__title"><a href="/2016/03/26/Node-js-Web-Crawler-with-Promise/">Node.js: Web Crawler with Promise</a></h1></header><div class="post__main echo"><h1 id="PTT-Crawler"><a href="#PTT-Crawler" class="headerlink" title="PTT Crawler"></a>PTT Crawler</h1><p>前幾天面試的時候被要求現場寫爬蟲，要爬PTT的文章，但當場寫的時候蠻趕的所以其實不是很滿意XD。回家後自己重新寫過，結果碰到Asynchronous的問題，剛好趁機把Promise給完全弄懂，發現Promise真的很強很好用！</p>
<p>當時需求是這樣的：把PTT某一版的文章爬100篇存到資料庫，然後可以的話順便寫個Server可以給前端呼叫、把文章叫出來，下面會一步步解說我怎麼實做的。</p>
<h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><p>我用的是MongoDB，以及用mongoose去操作，所以我先定義了Schema，名稱叫Ptt；其中article是html內容，url是文章的網址，然後count是文章的序號、可以作為之後讓前端呼叫用的參數。Code如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ptt.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Ptt = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  article: <span class="built_in">String</span>,</span><br><span class="line">  url: <span class="built_in">String</span>,</span><br><span class="line">  count: <span class="built_in">Number</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  versionKey: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'Ptt'</span>, Ptt);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>在Crawler這邊我用了三個packages，分別為：request、mongoose和cheerio。request是拿來抓html用的，mongoose操作MongoDB，cheerio是拿來分析html用的package。前面兩個應該比較耳熟能詳，cheerio應該大家比較沒聽過，他的概念就是在Node.js裡面提供一套jQuery的核心操作，非常方便，因此用這個套件就像在用jQuery，使用方法我就不多說了大家可以查API，後面會有我的使用過程XD。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// crawler.js</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Ptt = <span class="built_in">require</span>(<span class="string">'./Ptt'</span>);</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/ptt'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="ParseIndex"><a href="#ParseIndex" class="headerlink" title="ParseIndex"></a>ParseIndex</h2><p>在寫Code前要先分析一下我們得怎麼做，大家可以先開Web版PTT，我在這邊用的例子是<a href="https://www.ptt.cc/bbs/Tech_Job/index.html" target="_blank" rel="external">Tech_Job版</a>。大家可以看到這個頁面有一堆超連結，這些超連結中屬於”文章”的就是我們的目標。按下上一頁後可以發現上面網址的index會加上序號，因此我一開始的打算是從第一頁開始爬每個頁面的超連結，爬完再爬上一頁、然後一直往前爬，每爬到一個超連結就request來拿到HTML。<em>但這樣做不會work</em>，因為當PTT那邊的Server收到太多次相同IP的request時他會擋你XD，所以要換個方法：</p>
<ol>
<li>一樣先一頁一頁index用request去parse，但不要去抓網頁，把URL存起來就好（存在URL-list）</li>
<li>把URL-list給整理好</li>
<li>等要parse的URL-list整理完後，以<code>setInterval(function(){}, interval)</code>定時request來抓網頁並存到Database</li>
</ol>
<p>上面聽起來蠻合理的，但問題出在：<strong>parse用的request是Asynchronous-function</strong>！因此假設從第一頁的index開始往前爬十頁，<em>代表我們要等這十頁爬完</em>、再去整理URL-list，然後再去一個一個URL去抓網頁。而這裡的等這十頁爬完就跟Promise有關啦，後面會詳細敘述。</p>
<p>下面我們先看ParseHTML這個function的Code：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse "href"s in the webpage of parsed_uri</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseHTMLhref</span>(<span class="params">parsed_uri, check_article_index</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// href_list is the list of all "href"s in the webpage of parsed_uri</span></span><br><span class="line">    <span class="keyword">var</span> href_list = [];</span><br><span class="line"></span><br><span class="line">    request(&#123;</span><br><span class="line">      uri: parsed_uri,</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// body is the parsed_uri's html</span></span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// ------Reject the promise------</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Error!"</span>);</span><br><span class="line">        reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ParseBody = cheerio.load(body);</span><br><span class="line">        <span class="comment">// fetch all contents of "&lt;a&gt;&lt;/a&gt;"</span></span><br><span class="line">        ParseBody(<span class="string">'a'</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">i, link</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> href = ParseBody(link).attr(<span class="string">'href'</span>);</span><br><span class="line">          <span class="keyword">if</span> (href) &#123;</span><br><span class="line">            <span class="comment">// Filt out the article's href</span></span><br><span class="line">            <span class="keyword">if</span> (href[check_article_index] == <span class="string">'M'</span>) &#123;</span><br><span class="line">              href_list.push(href);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// ------Resolve the promise------</span></span><br><span class="line">        resolve(href_list.reverse());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parsed_uri是我們要爬的index頁面，第五行的部分可以看到這個function會回傳一個Promise。而我們會在href_list這裡存放這個index頁面中符合條件的文章URL。Promise我們可以先想像成他有兩種回傳值，一種是成功的完成，會回傳resolve，另一種是完成失敗的回傳值，會回傳reject。我們可以看到request的部分當出現error的時候我們就把這個Promise的reject塞入”It broke”，而成功時把最終結果塞入Promise的resolve。</p>
<p>中間的ParseBody就是使用cheerio的部分了。我們可以用<code>cheerio.load(body)</code>來創建一個虛擬的DOM，而這個DOM就是ParseBody。那麼在呼叫<code>ParseBody(&#39;a&#39;)</code>時，我們可以拿到這個index頁面所有的<a></a>DOM物件，在這裡會以JSON格式來表示所以map才有兩個參數。而map裡第一行的<code>var href = ParseBody(link).attr(&#39;href&#39;);</code>就是把每個<a></a>中的超鏈結擷取出來，放入變數<code>var href</code>內，然後再將其push到<code>href_list</code>裡。</p>
<p>裡面有一行<code>if (href[check_article_index] == &#39;M&#39;)</code>是拿來確認這個URL是否為文章，大家可以觀察每篇文的URL就知道為什麼我要這樣做了XD。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise去年才變成ECMAScript的標準，查找ECMAScript6可以看得到，其主要功能就是處理非同步的Callback。實際使用方式我覺得直接看例子會比較好懂：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do a thing, possibly async, then…</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* everything turned out fine */</span> <span class="number">1</span>==<span class="number">1</span>) &#123;</span><br><span class="line">    resolve(<span class="string">"Stuff worked!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="built_in">Error</span>(<span class="string">"It broke"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面是一段創建Promise的code，一個Promise會需要resolve和reject兩個<code>function</code>，<em>其中resolve是你成功執行後會再進一步呼叫的function，而reject是失敗後會呼叫的function</em>。那麼要怎麼使用呢？可以看下面的code：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// "Stuff worked!"</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// Error: "It broke"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>promiseX.then(functionA(a), functionB(b))</code>就是使用Promise的其中一個方法：若promiseX成功了，那麼<code>.then</code>會自動幫你呼叫functionA並且把參數帶入a。前面對應到functionA的就是<code>resolve(&quot;Stuff worked!&quot;)</code>，這邊會將”Stuff worked!”作為functionA的參數a代入並去呼叫functionA。而functionB對應到的就是<code>reject(Error(&quot;It broke&quot;))</code>，同理。</p>
<p><img src="promises.png" alt="Promise"></p>
<p>上面是從MDN官網上截下來的圖，可以從這邊看到”一個”Promise的流程，基本上就是一直在resolve和reject中選一條路繼續往下走。<strong>要注意的是<code>.then</code>執行完後return的一樣是Promise</strong>，因此可以一直chained下去。接下來在後面會講解如何應付多個Promise。</p>
<h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><p>接下來是主要的code，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// url parameters</span></span><br><span class="line">  <span class="keyword">var</span> domain = <span class="string">'https://www.ptt.cc'</span></span><br><span class="line">  <span class="keyword">var</span> board = <span class="string">"/bbs/Tech_Job/"</span>;</span><br><span class="line">  <span class="keyword">var</span> ptt_board = board + <span class="string">"index"</span>;</span><br><span class="line">  <span class="keyword">var</span> html_tail = <span class="string">".html"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> check_article_index = board.length;</span><br><span class="line">  <span class="keyword">var</span> promise_list = [];</span><br><span class="line">  <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First page</span></span><br><span class="line">  promise_list.push(ParseHTMLhref(domain + ptt_board + html_tail, check_article_index));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From index2147 to indexXXXX</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2147</span>; i &gt; <span class="number">2145</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">var</span> combined_url = domain + ptt_board + i + html_tail;</span><br><span class="line">    promise_list.push(ParseHTMLhref(combined_url, check_article_index));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for all Promises in the promise_list</span></span><br><span class="line">  <span class="built_in">Promise</span>.all(promise_list).then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log(values); // [3, 1337, "foo"]</span></span><br><span class="line">    <span class="keyword">var</span> combined_url_list = [];</span><br><span class="line">    values.map((temp_list) =&gt; &#123;</span><br><span class="line">      combined_url_list = combined_url_list.concat(temp_list);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(combined_url_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">var</span> fetched_url = combined_url_list.shift();</span><br><span class="line">      <span class="keyword">if</span> (!fetched_url) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Totally "</span> + cnt + <span class="string">" articles."</span>);</span><br><span class="line">        mongoose.disconnect();</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GetArticle(domain + fetched_url, cnt);</span><br><span class="line">        cnt = cnt + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>用closure包起來是好習慣，所以就先包一下了XD。說明：第十行的<code>promise_list</code>是用來存放Promise物件的陣列，第十四到十九行可以看到這邊呼叫了很多個ParseHTML塞進<code>promise_list</code>裡面。沒有很複雜，就只是parse index、index2147、index2146⋯⋯等的索引頁中的文章URL。</p>
<p>接下來才是關鍵：第二十二行的<code>Promise.all([promise-array]).then(()=&gt;{})</code>。這裡<code>.all([promise-array])</code>的意思是<strong>等待promise-array中所有Promise結束</strong>，才去call <code>.then()</code>。這裡是我認為Promise中最強大的其中一個功能之一，可以等待Async.並進行處理。因此我們在二十二行<code>.then()</code>的function裡面所看到的<code>values</code>就是<code>promise_list</code>裡面所有Promise執行完畢後回傳的結果。而combined_url_list只是把這些結果串在一起而已。</p>
<p>後面就很簡單了，有了照順序排列的所有URL的list後，用<code>setInterval()</code>來定時去request並存到資料庫就可以了。GetArticle就是request &amp; save的function：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the article from the url</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetArticle</span>(<span class="params">complete_url, countNum</span>) </span>&#123;</span><br><span class="line">  request.get(&#123;</span><br><span class="line">    url: complete_url</span><br><span class="line">  &#125;, (err, response, body) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Get one article: "</span> + complete_url);</span><br><span class="line">    <span class="comment">// Create a document and save the html of the complete_url</span></span><br><span class="line">    <span class="keyword">new</span> Ptt(&#123;</span><br><span class="line">      article: body,</span><br><span class="line">      url: complete_url,</span><br><span class="line">      count: countNum</span><br><span class="line">    &#125;).save();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整個Crawler的運作大概就是這樣了XD，其餘的Code我放在<a href="https://github.com/AnCheTeng/ptt_crawler" target="_blank" rel="external">我的GitHub</a>上了，使用方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">node crawler.js</span><br></pre></td></tr></table></figure>
<p>跑crawler的時候請耐心等待XD，應該會看到像下面的output：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427945137.A.3A3.html</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427945136.A.1D1.html</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427940003.A.A35.html</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427939388.A.1F2.html</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427938495.A.E59.html</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427936593.A.F3A.html</span><br><span class="line">Get one article: https://www.ptt.cc/bbs/Tech_Job/M.1427921152.A.3B2.html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>爬完後開啟server.js：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure>
<p>打開瀏覽器輸入：”localhost:8080/3”，就可以看到爬到的文啦XD！後面的數字代表的是爬到的文章順序數，大家可以多看幾篇XDDD</p>
<p>有問題可以在下面留言唷～</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/node/" class="post__tag__link">node</a></li><li class="post__tag__item"><a href="/tags/express/" class="post__tag__link">express</a></li><li class="post__tag__item"><a href="/tags/javascript/" class="post__tag__link">javascript</a></li><li class="post__tag__item"><a href="/tags/promise/" class="post__tag__link">promise</a></li></ul><a href="/2016/03/26/Node-js-Web-Crawler-with-Promise/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2016-03-18T04:28:08.000Z" class="post__time">March 18, 2016</time><h1 class="post__title"><a href="/2016/03/18/Node-js-Stream-I/">Node.js: Stream (I) </a></h1></header><div class="post__main echo"><h1 id="為什麼要用Stream"><a href="#為什麼要用Stream" class="headerlink" title="為什麼要用Stream?"></a>為什麼要用Stream?</h1><p>在Node.js裡面，I/O都是asynchronous的，因此我們在處理網路或硬碟裡數據的時候通常都會使用callback function。我們可能寫出下面這種Code：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>
<p>看起來沒甚麼問題，但當data.txt很大的時候，每次request進來我們都必須把整個data.txt讀到記憶體內，再把結果回傳給Client。因此在Client端就必須要等待這整個讀取時間，bad user experience。</p>
<a id="more"></a>
<p>但因為在Node中，http的requese和response都是Stream，因此我們可以用<code>.pipe()</code>來達成上面的需求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</span><br><span class="line">    stream.pipe(res);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>
<p>上面的Code中，<code>.pipe()</code>會負責處理<code>data</code>和<code>end</code>的Stream Event，因此data.txt會以”一個一個的chunk”的方式把資料傳送給Client端。</p>
<p>除此之外用<code>.pipe()</code>還有其他好處，像是自動處理背壓(Backpressure)，意思是在Client端要是網路速度很慢的時候Server端也會相應調整輸出chunk的速度。</p>
<h1 id="小實驗：pipe-VS-fs-readFile"><a href="#小實驗：pipe-VS-fs-readFile" class="headerlink" title="小實驗：pipe VS. fs.readFile"></a>小實驗：pipe VS. fs.readFile</h1><p>光用看的可能沒感覺，因此我寫了一段程式來測試兩者消耗的記憶體有多大。data.txt大約是個10MB大小的文檔，然後每0.5秒會顯示目前Node v8引擎的記憶體使用量，使用方式為：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node StreamTest.js Bulk</span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node StreamTest.js Stream</span><br></pre></td></tr></table></figure>
<p>Source Code如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StreamTest.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (process.argv[<span class="number">2</span>]) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the pipe to respond the request</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Stream"</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=====Create a Stream-Server====="</span>)</span><br><span class="line">    <span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</span><br><span class="line">      stream.pipe(res);</span><br><span class="line">    &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the traditional way to respond the request</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Bulk"</span>:</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"=====Create a Bulk-Server====="</span>)</span><br><span class="line">    <span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            res.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Usage: node test.js [Stream/Bulk]"</span>)</span><br><span class="line">    process.abort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the memory usage each 500 ms</span></span><br><span class="line">setInterval( ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">var</span> info = process.memoryUsage();</span><br><span class="line">  <span class="keyword">var</span> mb = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (v / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>) + <span class="string">'MB'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'rss=%s, heapTotal=%s, heapUsed=%s'</span>, mb(info.rss), mb(info.heapTotal), mb(info.heapUsed));</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>我們可以先來測試readFile的時候消耗的記憶體情形，開啟Server後，打開瀏覽器連續輸入十次<code>localhost:8000</code>，應該可以看到下面這種結果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">=====Create a Bulk-Server=====</span><br><span class="line">...</span><br><span class="line">rss=18.05MB, heapTotal=9.14MB, heapUsed=4.34MB</span><br><span class="line">rss=18.05MB, heapTotal=9.14MB, heapUsed=4.34MB</span><br><span class="line">rss=30.00MB, heapTotal=9.14MB, heapUsed=4.63MB</span><br><span class="line">rss=41.59MB, heapTotal=9.14MB, heapUsed=4.72MB</span><br><span class="line">rss=41.59MB, heapTotal=9.14MB, heapUsed=4.73MB</span><br><span class="line">rss=64.64MB, heapTotal=9.14MB, heapUsed=4.76MB</span><br><span class="line">rss=64.64MB, heapTotal=9.14MB, heapUsed=4.76MB</span><br><span class="line">rss=64.64MB, heapTotal=9.14MB, heapUsed=4.76MB</span><br><span class="line">rss=76.16MB, heapTotal=9.14MB, heapUsed=4.78MB</span><br><span class="line">rss=76.16MB, heapTotal=9.14MB, heapUsed=4.78MB</span><br><span class="line">rss=76.16MB, heapTotal=9.14MB, heapUsed=4.78MB</span><br><span class="line">rss=87.69MB, heapTotal=9.14MB, heapUsed=4.80MB</span><br><span class="line">rss=87.69MB, heapTotal=9.14MB, heapUsed=4.80MB</span><br><span class="line">rss=87.69MB, heapTotal=9.14MB, heapUsed=4.81MB</span><br><span class="line">rss=122.26MB, heapTotal=9.14MB, heapUsed=4.85MB</span><br><span class="line">rss=133.78MB, heapTotal=9.14MB, heapUsed=4.87MB</span><br><span class="line">rss=133.78MB, heapTotal=9.14MB, heapUsed=4.87MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>可以看到記憶體用量從18.05MB增加到133.78MB，很明顯是在處理這十次的request。現在我們換用pipe的方式來做一樣的實驗：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=====Create a Stream-Server=====</span><br><span class="line">...</span><br><span class="line">rss=18.09MB, heapTotal=9.14MB, heapUsed=4.34MB</span><br><span class="line">rss=18.09MB, heapTotal=9.14MB, heapUsed=4.34MB</span><br><span class="line">rss=19.91MB, heapTotal=9.14MB, heapUsed=4.75MB</span><br><span class="line">rss=23.69MB, heapTotal=9.14MB, heapUsed=5.04MB</span><br><span class="line">rss=23.70MB, heapTotal=9.14MB, heapUsed=5.05MB</span><br><span class="line">rss=23.70MB, heapTotal=9.14MB, heapUsed=5.05MB</span><br><span class="line">rss=32.46MB, heapTotal=9.14MB, heapUsed=5.83MB</span><br><span class="line">rss=28.93MB, heapTotal=7.19MB, heapUsed=5.60MB</span><br><span class="line">rss=28.93MB, heapTotal=7.19MB, heapUsed=5.61MB</span><br><span class="line">rss=28.93MB, heapTotal=7.19MB, heapUsed=5.61MB</span><br><span class="line">rss=32.87MB, heapTotal=7.19MB, heapUsed=5.96MB</span><br><span class="line">rss=32.87MB, heapTotal=7.19MB, heapUsed=5.96MB</span><br><span class="line">rss=21.33MB, heapTotal=7.19MB, heapUsed=5.23MB</span><br><span class="line">rss=21.33MB, heapTotal=7.19MB, heapUsed=5.23MB</span><br><span class="line">rss=21.33MB, heapTotal=7.19MB, heapUsed=5.24MB</span><br><span class="line">rss=31.94MB, heapTotal=9.13MB, heapUsed=5.13MB</span><br><span class="line">rss=31.94MB, heapTotal=9.13MB, heapUsed=5.14MB</span><br><span class="line">rss=36.58MB, heapTotal=9.13MB, heapUsed=5.43MB</span><br><span class="line">rss=36.58MB, heapTotal=9.13MB, heapUsed=5.43MB</span><br><span class="line">rss=37.27MB, heapTotal=9.13MB, heapUsed=5.48MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我們可以很明顯地看到用量上的差異，在文檔更大的時候會更明顯，蠻有趣的。</p>
<p>待續．．．Stream (II)</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ul>
<li><a href="https://github.com/substack/stream-handbook" target="_blank" rel="external">stream-handbook</a></li>
<li><a href="https://github.com/zoubin/streamify-your-node-program" target="_blank" rel="external">streamify-your-node-program</a></li>
<li><a href="http://maxogden.com/node-streams.html" target="_blank" rel="external">Node Streams: How do they work?</a></li>
<li><a href="http://morning.work/page/2015-07/read_and_write_big_file_in_nodejs.html" target="_blank" rel="external">Node.js with large file I/O</a></li>
<li><a href="https://nodejs.org/docs/latest/api/stream.html#stream_readable_unpipe_destination" target="_blank" rel="external">Node.js Stream Module</a></li>
</ul>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/node/" class="post__tag__link">node</a></li><li class="post__tag__item"><a href="/tags/stream/" class="post__tag__link">stream</a></li></ul><a href="/2016/03/18/Node-js-Stream-I/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016 鄧安哲</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","angelsmeanstack","count");
</script></body></html>